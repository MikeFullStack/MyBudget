rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // 1. User Data & Budgets (Owned)
    match /artifacts/mon-budget/users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;

      match /budgets/{budgetId} {
        // Owner full access
        allow read, write: if request.auth != null && request.auth.uid == userId;
        
        // Transactions Subcollection (Owner)
        match /transactions/{txId} {
          allow read, write: if request.auth != null && request.auth.uid == userId;
        }
      }
    }

    // 2. Shared Access (Collection Group)
    // We allow reading budgets where user is a participant.
    // NOTE: Writing to shared budgets requires knowing the path, which currently must be 'artifacts/mon-budget/users/{ownerId}/budgets/{budgetId}'
    match /{path=**}/budgets/{budgetId} {
      allow read: if request.auth != null && resource.data.participants.hasAny([request.auth.token.email]);
      
      // Allow updating ONLY if participant (e.g. adding transaction?)
      // For strict security, we'd need to verify the path owner, but for now we trust the participants list on the doc.
      allow update: if request.auth != null && resource.data.participants.hasAny([request.auth.token.email]);
      
      // Subcollection access for shared budgets
      match /transactions/{txId} {
        // We need to check the PARENT budget's participants. 
        // Firestore rules cannot easily read parent doc in collection group query context efficiently without 'get'.
        // BUT, since we are usually accessing via known path for writes:
        allow read, write: if request.auth != null && 
                           get(/databases/$(database)/documents/$(path)/budgets/$(budgetId)).data.participants.hasAny([request.auth.token.email]);
      }
    }
  }
}
